<!DOCTYPE html>
<html lang="">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="李英平">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="李英平">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog,李英平,程序员,DUT">
    
    <meta name="description" content="">
    <meta name="description" content="绪言  面向对象程序设计的特点：模块化、数据隐藏、继承、多态性、重载。  C++语言程序的开发过程：编辑程序源文件（.cpp）→ 编译生成目标文件（.obj）→ 链接生成可执行文件（.exe）→ 执行文件。   数据类型、运算符与基本语句 基本概念 标识符：用来标识程序中所用到的变量名、函数名、类型名、数组名、文件名以及符号常量名的有效字符序列。  C++标识符的命名规则：由字母、数字以及下划线组">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++语言程序设计教程》读书笔记">
<meta property="og:url" content="http://bye-lemon.github.io/post/ab83/index.html">
<meta property="og:site_name" content="Li.">
<meta property="og:description" content="绪言  面向对象程序设计的特点：模块化、数据隐藏、继承、多态性、重载。  C++语言程序的开发过程：编辑程序源文件（.cpp）→ 编译生成目标文件（.obj）→ 链接生成可执行文件（.exe）→ 执行文件。   数据类型、运算符与基本语句 基本概念 标识符：用来标识程序中所用到的变量名、函数名、类型名、数组名、文件名以及符号常量名的有效字符序列。  C++标识符的命名规则：由字母、数字以及下划线组">
<meta property="og:locale">
<meta property="article:published_time" content="2018-10-29T04:43:55.000Z">
<meta property="article:modified_time" content="2021-01-17T05:45:09.000Z">
<meta property="article:author" content="李英平">
<meta property="article:tag" content="DUT">
<meta property="article:tag" content="备考">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>《C++语言程序设计教程》读书笔记 · Li Yingping&#39;s Studio</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Li." type="application/atom+xml">
</head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>Li Yingping's Studio.</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">Li Yingping&#39;s Studio.</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">《C++语言程序设计教程》读书笔记</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                《C++语言程序设计教程》读书笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="DUT">DUT</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="备考">备考</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="C++">C++</a>
    
</div>

                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">11.8k</span>阅读时长: <span class="post-count reading-time">43 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2018/10/29</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h2 id="绪言"><a href="#绪言" class="headerlink" title="绪言"></a>绪言</h2><hr>
<ul>
<li><p>面向对象程序设计的特点：模块化、数据隐藏、继承、多态性、重载。</p>
</li>
<li><p>C++语言程序的开发过程：编辑程序源文件（.cpp）→ 编译生成目标文件（.obj）→ 链接生成可执行文件（.exe）→ 执行文件。</p>
</li>
</ul>
<h2 id="数据类型、运算符与基本语句"><a href="#数据类型、运算符与基本语句" class="headerlink" title="数据类型、运算符与基本语句"></a>数据类型、运算符与基本语句</h2><hr>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>标识符：用来标识程序中所用到的变量名、函数名、类型名、数组名、文件名以及符号常量名的有效字符序列。</p>
</li>
<li><p>C++标识符的命名规则：由字母、数字以及下划线组成，第一个字符必须是字母或下划线。</p>
</li>
<li>常量是程序运行过程中值不能被改变的量；变量是程序运行过程中值可以被改变的量；关键字也是C++的一种标识符，他用来命名C++语言中的语句、数据类型和变量属性等，有其固定意义，不可另作其他用途，亦称保留字。</li>
</ul>
<h3 id="C-的数据类型"><a href="#C-的数据类型" class="headerlink" title="C++的数据类型"></a>C++的数据类型</h3><ul>
<li><p>C++语言中的基本数据类型有：<code>bool</code>、<code>int</code>、<code>char</code>、<code>float</code>、<code>double</code>、<code>void</code>等。</p>
<ul>
<li><code>void</code>型是不具有值的特殊数据类型，主要用在函数值类型说明以及指针类型说明，不存在<code>void</code>型一般变量。</li>
<li><p><code>bool</code>型变量只保存真假值，一般用于判断语句，<code>bool</code>型常量有两个<code>true</code>和<code>false</code>。</p>
</li>
<li><p><code>int</code>型变量的前面可以加上<code>short</code>或<code>long</code>定义短整型或长整型变量；可以在<code>double</code>前面加上<code>long</code>定义长浮点数变量；可以在<code>int</code>前加上<code>signed</code>或<code>unsigned</code>定义有符号整型变量或无符号整型变量，在不加修饰的情况下，<code>int</code>默认为有符号数。</p>
</li>
</ul>
</li>
<li>枚举类型：枚举类型适用于某一变量在小范围内取值的情况，使用枚举类型可以提高程序的可读性。枚举型变量的定义方式如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义枚举类型，后声明变量。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red, yellow, blue&#125;;</span><br><span class="line">color c;</span><br><span class="line"><span class="comment">// 在定义枚举类型的同时声明变量。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red, yollow, blue&#125; c;</span><br><span class="line"><span class="comment">// 直接声明枚举变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>red, yellow, blue&#125; c;</span><br></pre></td></tr></table></figure></li>
<li>枚举类型中的每一个枚举元素对应一个整数值，这个值可以通过定义显式地给出，否则按照$0，1，2……$的顺序递增。故而，枚举类型可以直接赋给整型变量，整型数也可以通过强制类型转换赋给一个枚举类型的变量。</li>
<li><p><code>const</code>关键字用来定义数值不能改变的变量；<code>volatile</code>关键字用来定义不需要系统进行最优化处理的变量；<code>typedef</code>关键字用来给已有的数据类型增加别名。</p>
</li>
<li><p><code>const</code>用于指针的定义时，其位置的不同，代表的含义也不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr1 = &amp;foo; <span class="comment">// 指针是常量，不能指向其他空间。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr2 = &amp;bar; <span class="comment">// 指针指向的bar变量是常量，不能被改变。</span></span><br></pre></td></tr></table></figure>
<h3 id="C-的运算符与基本语句"><a href="#C-的运算符与基本语句" class="headerlink" title="C++的运算符与基本语句"></a>C++的运算符与基本语句</h3></li>
<li>C++语言的运算符与基本语句和C语言别无二致，故按下不表。不过值得一提的是，老师反复强调了一组运算符的优先级关系，这个关系在对复杂指针的解析时颇有帮助。<blockquote>
<p>“括号的优先级是高于星号的，不论是方括号还是圆括号。”</p>
<div style="text-align: right"> <i>—— 孟宪福老师<i> </div>

</blockquote>
</li>
</ul>
<h2 id="数据的输入和输出"><a href="#数据的输入和输出" class="headerlink" title="数据的输入和输出"></a>数据的输入和输出</h2><hr>
<p>C++语言支持C语言中的函数来进行标准输入输出和文件处理，如<code>scanf()</code>函数、<code>printf()</code>函数等，只要在源文件的首部通过<code>#include</code>指令将stdio.h头文件包含进来即可。除此之外，C++还可以利用系统提供的流类来进行标准输入输出和文件处理。</p>
<h3 id="标准输入和输出"><a href="#标准输入和输出" class="headerlink" title="标准输入和输出"></a>标准输入和输出</h3><ul>
<li>C++语言的标准输入输出是由以下三个流类构成的：<code>istream</code>、<code>ostream</code>、<code>iostream</code>，三者均在iostream.h中定义。当iostream.h被包含进源文件后会自动创建4个流类对象：标准输入流<code>cin</code>、标准输出流<code>cout</code>、非缓冲型的标准出错流<code>cerr</code>、缓冲型的标准出错流<code>clog</code>。</li>
<li>对于流对象<code>cin</code>、<code>cout</code>中的输入输出数据可以通过提取运算符<code>&gt;&gt;</code>和插入运算符<code>&lt;&lt;</code>进行标准输入输出，<code>cin</code>和<code>cout</code>能够自动识别变量的数据类型，因此在出入输出时不需要显式地指定数据类型。基于<code>&gt;&gt;</code>和<code>&lt;&lt;</code>的标准输入输出支持连续的输入输出，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a; <span class="keyword">long</span> b; <span class="keyword">double</span> c; <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Input a string, then int long double&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;String: &quot;</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; A= &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; B= &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; C= &quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>cout</code>对象利用插入运算符进行输出时，默认按照待输出数值或字符串的最低域宽进行输出，若要显式地指定输出的域宽，需要使用<code>cout</code>对象的<code>width()</code>方法，但是需要注意的是，<strong>域宽设置在一个待输出内容的输出完成之后就会失效</strong>。在设定了域宽之后，数据长度小于域宽的部分将默认由空格补足，使用<code>fill()</code>方法可以显式地指定填充字符，与之前不同的是，<strong>使用<code>fill()</code>方法指定的填充字符会一直有效，直到设定了新的填充字符为止</strong>。</li>
<li><code>cout</code>对象可以通过<code>precision()</code>方法来指定浮点数的输出精度（整数部分和小数部分的总位数，不计小数点。），数据宽度超过精度的部分按照四舍五入的方法社区舍去。</li>
<li>在输入输出的过程中，C++支持使用控制符转化为指定的格式，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo = <span class="number">255</span>, bar;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;foo&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;hex&gt;bar;</span><br></pre></td></tr></table></figure></li>
<li>C++语言的控制符有：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">控制符</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">oct</td>
<td style="text-align:center">八进制数处理</td>
<td style="text-align:center">输入输出</td>
</tr>
<tr>
<td style="text-align:center">dec</td>
<td style="text-align:center">十进制数处理</td>
<td style="text-align:center">输入输出</td>
</tr>
<tr>
<td style="text-align:center">hex</td>
<td style="text-align:center">十六进制数处理</td>
<td style="text-align:center">输入输出</td>
</tr>
<tr>
<td style="text-align:center">ws</td>
<td style="text-align:center">跳过空格</td>
<td style="text-align:center">输入</td>
</tr>
<tr>
<td style="text-align:center">flush</td>
<td style="text-align:center">刷新缓冲区（强制输出）</td>
<td style="text-align:center">输出</td>
</tr>
<tr>
<td style="text-align:center">endl</td>
<td style="text-align:center">输出时追加’\n’并刷新缓冲区</td>
<td style="text-align:center">输出</td>
</tr>
<tr>
<td style="text-align:center">ends</td>
<td style="text-align:center">输出时追加’\0’并刷新缓冲区</td>
<td style="text-align:center">输出</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在C++语言中还可以使用<code>cin</code>和<code>cout</code>两个类的方法<code>get()</code>、<code>put()</code>、<code>getline()</code>等进行输入输出。</li>
</ul>
<h3 id="C-的文件处理"><a href="#C-的文件处理" class="headerlink" title="C++的文件处理"></a>C++的文件处理</h3><ul>
<li>C++与文件相关的流类有三个：<code>ifstream</code>、<code>ofstream</code>、<code>fstream</code>，它们均被定义在头文件fstream.h中，将头文件包含入源文件中后，可以通过以下语句定义输入输出流：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream fin;</span><br><span class="line">ofstream fout;</span><br></pre></td></tr></table></figure></li>
<li>文件的打开使用流类对象的<code>open()</code>方法，<code>open()</code>方法需要三个参数：fname参数为指向文件名的指针，openmode为文件的打开模式，prot为文件的保护种类，一般采用默认值。在<code>fin</code>和<code>fout</code>中<code>open()</code>的定义分别为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * fname, <span class="keyword">int</span> openmode = ios:in, <span class="keyword">int</span> prot = filebut::openprot)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * fname, <span class="keyword">int</span> openmode = ios:out, <span class="keyword">int</span> prot = filebut::openprot)</span></span></span><br></pre></td></tr></table></figure></li>
<li>当对于文件的操作完成之后，可以使用<code>close()</code>方法将文件关闭。</li>
<li><p>对于文件的输入和输出与标准输入输出类似，标准输入输出的<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>put()</code>、<code>get()</code>、<code>getline()</code>在文件操作中均可以使用。除此之外，可以通过<code>seekp()</code>、<code>tellg()</code>的方法设置和获取文件输出流的指针，通过<code>seekg()</code>、<code>tellg()</code>的方法获取文件输入流的指针。</p>
</li>
<li><p>C++语言提供一些错误处理的方法，使用<code>fail()</code>方法可以判断输入输出错误，与此对应的,<code>good()</code>方法可以判断输入输出是否正常。<code>eof()</code>方法提供了对于是否到文件结尾的判断信息。</p>
</li>
<li>下面给出一个文件处理的示例程序，程序将读入一个文件，将其中内容写入另一个文件的同时显示在屏幕上。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    fin.open(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fin.fail()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Input File Open Error!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.open(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fin.fail()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Output File Open Error!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fin.get(ch)) &#123;</span><br><span class="line">        fout.put(ch);</span><br><span class="line">        <span class="built_in">cout</span>.put(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组、指针和引用"><a href="#数组、指针和引用" class="headerlink" title="数组、指针和引用"></a>数组、指针和引用</h2><hr>
<p>在C++语言中，数组和指针的用法与C语言基本类似，不再赘述。</p>
<h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><ul>
<li><p>在声明数组时，使用<code>static</code>关键字修饰，会使数组中各元素被赋上初值0，未加<code>static</code>关键字时，数组中各元素若未被一并显式赋值，其初值不能确定。</p>
</li>
<li><p>在C语言中<code>void</code>类型的指针与其它类型的指针可以任意相互赋值，但是在C++语言中将<code>void</code>类型的指针赋给其它类型的指针时，必须进行强制类型转换。</p>
</li>
<li><p>数组名相当于一个指针变量的名字，其值为数组中第一个元素的地址。</p>
</li>
<li><p>如果一个数组的每一个元素都是一个指针类型的数据，那么，称这个数组为指针数组。其定义形式为<code>类型说明符 * 数组名[常量表达式]</code>。在下面的例子中，<code>ptr</code>是一个数组的名字，数组中的每一个元素均为<code>char</code>型指针，指针分别指向”Hello”、”,”、<code>world</code>、<code>!</code>四个字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * ptr[] = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>对于一个多维数组，指向该数组的指针的定义如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[A][B]……[Z];</span><br><span class="line"><span class="keyword">int</span> (* ptr)[B][C]……[Z];</span><br><span class="line">ptr = <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3></li>
<li>引用是一个变量的别名，它自动适应于间接访问运算符<code>*</code>。但引用变量中的值（地址值）是不能被改变的。下面是一个引用变量的声明和使用的例子，在例子中，<code>y</code>是引用变量，是变量<code>x</code>的别名，即<code>y</code>与<code>x</code>代表着同一个变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> &amp;y = x;</span><br><span class="line"></span><br><span class="line">y = <span class="number">65535</span>;</span><br></pre></td></tr></table></figure></li>
<li>引用变量在被设定了指向某一变量的地址之后就不能再修改了，因此，在程序中定义引用变量必须要就地初始化。</li>
</ul>
<h3 id="内存的申请与释放"><a href="#内存的申请与释放" class="headerlink" title="内存的申请与释放"></a>内存的申请与释放</h3><ul>
<li>C++接受使用C语言中的<code>malloc()</code>函数和<code>free()</code>函数来进行内存的申请和释放。除此之外，C++提供了<code>new</code>和<code>delete</code>两个运算符来管理内存，<code>new</code>与<code>delete</code>的使用不需要调用头文件。<code>new</code>和<code>delete</code>的使用方法如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单变量的内存调用与释放</span></span><br><span class="line"><span class="keyword">int</span> * foo;</span><br><span class="line">foo = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> foo;</span><br><span class="line"><span class="comment">// 数组的内存调用与释放</span></span><br><span class="line"><span class="keyword">int</span> * bar = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];</span><br><span class="line"><span class="keyword">delete</span> []bar;</span><br><span class="line"><span class="keyword">int</span> (* baz)[SIZE1][SIZE2];</span><br><span class="line">baz = <span class="keyword">new</span> <span class="keyword">int</span>[NUM][SIZE1][SIZE2];</span><br><span class="line"><span class="keyword">delete</span> []baz;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr>
<h3 id="返回指针和引用的函数"><a href="#返回指针和引用的函数" class="headerlink" title="返回指针和引用的函数"></a>返回指针和引用的函数</h3><ul>
<li>函数不但能够返回值，也可以返回一个指针，这个指针可以指向一般的简单变量，也可以指向数组等。当函数返回一个指针时，该函数可以作为表达式的左值。函数可以返回动态申请的变量、静态变量或全局变量的指针，试图返回<code>auto</code>型变量的用法师是错误的。</li>
<li>C++中的函数不可以返回一个数组，但函数的返回值可以是指向数组的指针。以一个返回指向二维数组的指针的函数为例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将返回指向被传入的数组的指针，下面简要的分析一下这个定义：</span></span><br><span class="line"><span class="comment">// 从标识符开始，foo的后面有个括号（括号优先级高于星号），说明foo是一个函数，函数的参数在括号中，是一个int型N×M的数组。</span></span><br><span class="line"><span class="comment">// 函数的返回值在标识符前面，是一个星号，说明函数返回了一个指针。指针指向了一个每行M个元素的二维数组，数组中的每一个元素都是int型的。</span></span><br><span class="line"><span class="keyword">int</span> (* foo(<span class="keyword">int</span> bar[][M]))[M] &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数的返回值也可以是引用，与返回指针的函数类似，返回引用的函数也可以作为表达式的左值，试图返回<code>auto</code>型变量的引用也是错误的用法。</li>
</ul>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul>
<li>C++语言中的函数原型包括函数返回值类型、函数名、圆括号和形参表。其中，形参表可以只给出每个形参的类型，而不必给出形参名，即使给出形参名，也可以不与函数定义中的形参同名。</li>
</ul>
<h3 id="变量的作用域和储存类"><a href="#变量的作用域和储存类" class="headerlink" title="变量的作用域和储存类"></a>变量的作用域和储存类</h3><ul>
<li>在C++语言中，变量的定义包含三个方面的内容：一是变量的数据类型，如<code>int</code>、<code>char</code>等；二是变量的作用域，是指一个变量能起作用的程序范围；三是变量的存储类，即变量（数据）在内存中的存储方法，不同的存储方法，将影响变量值的生命周期。</li>
<li><p>C++里将一对花括号’{‘和’}’围起来的区域称作一个“块”，在块内定义的变量其作用域局限于所在的快，从所定义的位置开始到块结束为止。变量在块内任何位置均可定义。具有块作用域的变量又称局部变量。在函数外部定义的变量拥有文件作用域，即从它定义的位置起到整个文件结束都有效。具有全局作用域的变量又称全局变量。</p>
</li>
<li><p>在C++语言中，变量的存储类共有四种：<code>auto</code>、<code>static</code>、<code>register</code>和<code>extern</code>。</p>
<ul>
<li><p><code>auto</code>存储类即自动存储类，是定义在函数内部的变量的默认存储类，自动类变量是在动态存储区中分配存储单元的，变量在未初始化时默认初值不确定，当函数返回时，自动类变量存放的数据就消失了。</p>
</li>
<li><p><code>static</code>存储类即静态存储类，其在静态存储区中分配存储空间，静态变量或静态对象在程序的执行过程中总是存在，即使函数调用结束，其中的静态变量和静态对象仍不消失，仍保持其数值。</p>
</li>
<li><p><code>register</code>存储类即寄存器存储类，为了提高自动类变量或函数参数的处理速度可以在这些变量前加上<code>register</code>关键字，以通知系统为这些变量分配寄存器存储其值。实际应用中，由于寄存器资源的有限，并不是每一个寄存器类变量都能存放在寄存器中。寄存器类变量能存储的数据类型也是有限的。</p>
</li>
<li><p><code>extern</code>存储类即外部存储类，如果在一个文件中要引用另一个文件中定义的变量，需要将这个变量声明为外部的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-中函数的新特性"><a href="#C-中函数的新特性" class="headerlink" title="C++中函数的新特性"></a>C++中函数的新特性</h3><ul>
<li><p>当函数调用在函数定义之前时，默认形参值必须在函数原型声明的形参表中给出；函数的调用在函数定义之后时，函数的默认形参值在函数的定义时给出即可，当然，这种情况下也可以在函数原型的参数表中给出默认参数值，但是不可以在函数原型和函数定义中同时给出。</p>
</li>
<li><p>函数的重载指在一个程序中存在多个重名的函数，C++支持函数的重载，只要函数的参数个数或参数类型不同即可。不过需要注意的是，当函数的重载与函数的默认参数一起使用时可能会引起非法定义，例如下面，当调用<code>foo(1, 2)</code>时由于默认参数的存在，编译器将无法确定调用哪一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> bar = <span class="number">1</span>, <span class="keyword">int</span> baz = <span class="number">2</span>, <span class="keyword">int</span> quz = <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> foo, <span class="keyword">int</span> bar)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>inline函数又被称为内联函数或内置函数，在编译时，内联函数的代码会被插入到调用它的语句的位置上，其作用类似于宏定义。不过，inline函数具有更好的安全性，宏是在文字一级对参数进行处理，而inline函数是以普通函数的形式将其展开。<code>inline</code>关键字只是向系统提出一种要求，是否编译为inline函数还是由系统决定，没有被<code>inline</code>关键字修饰的函数也有可能被编译成inline函数。另一个需要注意的是，内联函数中不能有循环体语句和<code>switch</code>语句。</li>
<li>函数在本质上都是外部的，若希望一个函数只在它所定义的文件中有效，而不能在其他文件中被调用，可以使用<code>static</code>关键字将其定义为静态函数。</li>
</ul>
<blockquote>
<p>“ 提到一个数组，就要想数组的元素是什么；提到一个指针，就要想指针指向了什么；提到一个函数，就要想函数的参数和返回值是什么。”<br> <div style="text-align: right"> <i>—— 孟宪福老师<i> </div></p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><hr>
<h3 id="类的基本概念"><a href="#类的基本概念" class="headerlink" title="类的基本概念"></a>类的基本概念</h3><ul>
<li><p>类是C++语言的重要组成部分，也是面向对象程序设计中的关键内容。类的定义相当于定义一种数据类型，而对象则是类的实例。类与对象的关系相当于数据类型与变量的关系。在类中，可以定义数据成员，也可以定义成员函数。数据成员是类中所包含的变量，它用于表示某种数据结构；成员函数则是用于对数据成员进行操作的函数。</p>
</li>
<li><p>在定义类时，可以对数据成员和成员函数的访问进行限制，C++支持三种访问控制权限：<code>public</code>、<code>private</code>、<code>protected</code>。</p>
<ul>
<li><p><code>public</code>：公共的，写在<code>public</code>关键字下的数据成员和成员函数都是公有的，所有的函数都可以访问这些成员。</p>
</li>
<li><p><code>private</code>：私有的，写在<code>private</code>关键字下面的数据成员和成员函数是私有的，只有该类的成员函数和友元才能访问。</p>
</li>
<li><p><code>protected</code>：受保护的，写在<code>protected</code>关键字下面的数据成员是受保护的，这些成员在具有<code>private</code>特性的同时，可以由派生类的成员函数来访问。</p>
</li>
<li><p>在定义类时，一般将数据成员定义为私有的，以便防止外部的任意访问，而成员函数一般定义为公有的，使其可以被外部调用。类中默认的访问控制权限是<code>private</code>。</p>
</li>
</ul>
</li>
<li>类的成员函数可以在类的内部定义也可以在类的外部定义。采用内部定义形式定义的函数被默认为<code>inline</code>函数；外部定义的函数若想定义为<code>inline</code>函数，可以在函数说明处加上<code>inline</code>关键字，也可以在函数定义中加，或者两处都加以修饰。采用外部定义时需要使用域限定运算符<code>::</code>，外部定义的一般形式如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooClass::barFunc</span><span class="params">(<span class="keyword">int</span> bazParm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Function Body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><ul>
<li><p>构造函数主要用于对类对象中的数据成员进行初始化，构造函数和其他函数一样可以带参数表，没有参数的构造函数又称默认构造函数。构造函数也同普通函数一样支持函数的重载。构造函数具有如下三个特征：</p>
<ul>
<li><p>构造函数的名字与类名相同。</p>
</li>
<li><p>构造函数没有返回值类型说明。</p>
</li>
<li>构造函数在生成类对象时被自动调用。</li>
</ul>
</li>
<li><p>使用构造函数给类中的数据成员赋值时可以使用函数体内赋值语句赋值，也可以使用初始化列表，但对于类对象、<code>const</code>类型变量和引用变量必须使用初始化列表，以下是一个使用初始化列表赋值的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fooClass::fooClass(<span class="keyword">int</span> bar, <span class="keyword">char</span> baz): cbar(bar), cbaz(baz) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Build Complete&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>析构函数主要用于对已申请的内存空间进行释放等后处理工作。与构造函数类似，如果在类中没有定义析构函数，系统会自动创建一个没有任何功能的析构函数。析构函数具有以下特征：</p>
<ul>
<li><p>析构函数的名字是类名前加上<code>~</code>符号。</p>
</li>
<li><p>析构函数没有返回值类型说明。</p>
</li>
<li><p>析构函数没有参数。</p>
</li>
<li><p>析构函数是在变量被释放时自动调用的。</p>
</li>
</ul>
</li>
<li><p>当类中的成员包含类对象时，其构造函数和析构函数的执行是有顺序的：在构造函数被调用时，会先调用类对象数据成员的构造函数，当有多个类对象时，按照他们在类中定义顺序依次调用对应类的构造函数而与他们在初始化列表中的初始化顺序无关，类对象的构造函数一一调用完毕，继续执行本类的构造函数体；析构函数的调用顺序是构造函数的严格逆序。</p>
</li>
</ul>
<h3 id="复制构造函数-amp-变换构造函数"><a href="#复制构造函数-amp-变换构造函数" class="headerlink" title="复制构造函数 &amp; 变换构造函数"></a>复制构造函数 &amp; 变换构造函数</h3><ul>
<li><p>复制构造函数又称拷贝构造函数，当定义一个类对象时，若希望将一个已存在的类对象的值赋给该类对象，则要调用复制构造函数。当定义复制构造函数时，一般是将同一个类的对象引用作为其参数。当一个复制构造函数的入口参数只有一个时，它也是一种变换构造函数。</p>
</li>
<li><p>对于一个类来说，复制构造函数是必需的，如果类中没有定义复制构造函数，系统将自动生成一个将对象的值原原本本复制的默认复制构造函数。需要注意的是，当类的数据成员含有指针时，存在深浅拷贝的问题。默认复制构造函数会使两个不同对象的指针指向同一块内存区域，这在多数情况下是不方便的，这时须自定义一个复制构造函数，为新对象的指针分配一块新的区域，并将源对象中指针指向区域的值赋给新对象。</p>
</li>
<li><p>复制构造函数的调用有三种情况：用一个已有的类对象去初始化另一个新对象时；以类对象为形参，在将实参对象传递给形参时；以类对象为返回值，在执行返回语句时。</p>
</li>
<li><p>变换构造函数又称转换构造函数，当一个构造函数只有一个参数时，就可以通过<code>=</code>运算符像使用赋值语句一样为类的对象进行初始化，我们把这种只有一个参数的构造函数叫做变换构造函数。</p>
</li>
<li>变换函数与变换构造函数不同，变换函数用于将对象中的数据成员返回，并支持对其进行一系列运算或处理之后返回。其定义的形式一般为<code>operator 变换的类型() &#123;return 返回值; &#125;</code>。需要注意的是，变换函数不能有参数且必须包含<code>return</code>语句。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span> baz); <span class="comment">// 变换构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;another); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>; <span class="comment">// 变换函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo::Foo(<span class="keyword">int</span> baz): bar(baz) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo::Foo(<span class="keyword">const</span> Foo &amp;another): bar(another.bar) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Foo::int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="number">65535</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">foo_copy</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> quz = <span class="keyword">int</span>(foo_copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><ul>
<li><p>对于某些特定的类，一些特定的数据成员的值是固定不变的，对于该类的所有对象都是一样的，他们不与某一个对象有关，而是与该类的所有对象都有关，这种数据成员就可以被定义为静态的。静态数据成员主要被应用于设定所有对象都共享的数据。</p>
</li>
<li><p>类中的成员函数也可以被声明为静态的，这时，这个成员函数将不具<code>this</code>指针，它将不与某个具体的对象相联系，而是属于类的。静态成员函数不能对一般的数据成员进行操作，通常它只能用来对静态数据成员进行处理。构造函数和析构函数不可以定义为静态的。</p>
</li>
</ul>
<h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ul>
<li><code>const</code>对象又称常对象，同定义一般的常变量一样，也可以用<code>const</code>关键字定义常对象，常对象被初始化以后就不能再改变了。由于C++不能判断类中的哪一个成员函数会对数据成员进行修改，所以被定义为常对象的对象中的普通成员函数都是被禁止使用的。为了使<code>const</code>对象中不会改变数据成员之的成员函数能够被使用，须在其声明和实现时，在函数名的后面加上<code>const</code>关键字。而对于会使数据成员改变的成员函数，即使加上<code>const</code>关键字修饰，也不能被常对象访问，这样的尝试会在编译中报错。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo::disp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;foo&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><ul>
<li>在调用类对象的成员函数时，系统将自动将指向类对象的<code>this</code>指针传给成员函数，<code>this</code>指针中存放了当前对象的地址。尽管<code>this</code>指针通常都是默认使用的，但在需要时，<code>this</code>指针也可以显式调用。</li>
</ul>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li><p>C++中的友元函数和友元类可以使与该类无关系的一般函数或其他类也能对该类当中的<code>private</code>数据成员进行访问。</p>
</li>
<li><p>在类中的函数说明前面加上<code>friend</code>关键字，就可以将该函数说明为友元函数，友元函数可以直接引用类中的私有变量。友元函数的说明可以出现在类中的私有、受保护或公有部分，其作用效果都是一样的。需要注意的是，在进行类的继承操作时，派生类中的友元函数，对其基类不起作用。</p>
</li>
<li><p>友元函数尽管在类中声明也可以在类中直接定义，但它并不是类的成员函数，它不属于该类。任何一个不是类的成员函数的函数（包括其他类的成员函数）都可以声明为该类的友元函数。当将一个类中的成员函数定义为另一个类的友元函数时，要将这个类定义在另一个类的前面。</p>
</li>
<li><p>当一个类作为另一个类的友元时，该类的所有成员函数都可以对另一个类中的所有的数据成员和成员函数进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;bar.bar&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">set_bar</span><span class="params">(Bar bar)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Foo::disp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Baz</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Bar bar, <span class="keyword">int</span> baz)</span> </span>&#123;</span><br><span class="line">        bar.bar = baz</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bar</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">    bar.bar = <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类的嵌套定义"><a href="#类的嵌套定义" class="headerlink" title="类的嵌套定义"></a>类的嵌套定义</h3><ul>
<li>在C++语言中，类的定义里面还可以包含类的定义，这就是类的嵌套定义。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line">    Foo(<span class="keyword">int</span> foo) &#123; bar = foo; &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">barDisp</span><span class="params">(Foo *foo)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Foo::Bar::barDisp(Foo *foo) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;foo-&gt;bar&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="number">65535</span>;</span><br><span class="line">    Foo::Bar bar;</span><br><span class="line">    bar.barDisp(&amp;foo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尽管嵌套定义的类在其父类的作用域内，但是内嵌类不具有直接访问父类成员的特权。内嵌类可以访问其父类中的<code>public</code>成员，这需要传入一个其父类对象的指针，利用该指针去访问父类的成员。同样的父类也不可以直接访问内嵌类的成员。所以，内嵌类只是在另一个类的内部定义而已。</li>
</ul>
<h3 id="对象数组与指向类的成员的指针"><a href="#对象数组与指向类的成员的指针" class="headerlink" title="对象数组与指向类的成员的指针"></a>对象数组与指向类的成员的指针</h3><ul>
<li>C++语言允许定义对象数组，在定义对象数组时，系统会调用构造函数对数组的每一个元素进行初始化（包括显式地或默认地）。这之后，由于数组的每一个元素便是一个对象了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123; foo = <span class="number">65535</span>; &#125;; <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="keyword">int</span> bar) &#123; foo = bar; &#125; <span class="comment">// 变换构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;foo&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Foo <span class="built_in">list</span>[<span class="number">10</span>] = &#123;Foo(), Foo(<span class="number">1</span>), <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 分别显式调用默认构造函数、显式调用构造函数、调用变换构造函数，其余7个元素隐式调用默认构造函数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt --) &#123;</span><br><span class="line">        <span class="built_in">list</span>[cnt].disp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>C++语言中允许定义指向类对象的指针，也可以定义指向类的成员的指针（包括非静态成员和静态成员）。</p>
<ul>
<li>指向类对象的指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bar)</span> </span>&#123; foo = bar; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Foo foo, *ptr;</span><br><span class="line">    ptr = &amp;foo;</span><br><span class="line">    ptr-&gt;<span class="built_in">set</span>(<span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>指向非静态数据成员的指针，声明方式为<code>类型说明符 类名:: *指针名</code>，赋值形式为<code>指针名= &amp;类名::数据成员名</code>，使用方式为<code>对象名.*指针名</code>。</li>
<li><p>指向非静态成员函数的指针，声明方式为<code>类型说明符 (类名:: *指针名)(参数表)</code>，赋值形式为<code>指针名 = 类名::成员函数名</code>，使用方式为<code>(对象名.*指针名)(参数表)</code>。</p>
</li>
<li><p>指向静态数据成员的指针，声明方式为<code>类型说明符 *指针名</code>，赋值形式为<code>指针名= &amp;类名::静态数据成员名</code>，使用方式为<code>*指针名</code>。</p>
</li>
<li>指向静态成员函数的指针，声明方式为<code>类型说明符 (*指针名)(参数表)</code>，赋值形式为<code>指针名 = 类名::成员函数名</code>，使用方式为<code>(*指针名)(参数表)</code>或<code>指针名(参数表)</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line">    <span class="keyword">static</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bar)</span> </span>&#123; foo = bar; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向非静态数据成员的指针</span></span><br><span class="line">    <span class="keyword">int</span> Foo:: *ptr;</span><br><span class="line">    ptr = &amp;Foo::bar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向非静态成员函数的指针</span></span><br><span class="line">    <span class="keyword">void</span> (Foo:: *fptr)(<span class="keyword">int</span>);</span><br><span class="line">    fptr = Foo::<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向静态数据成员的指针</span></span><br><span class="line">    <span class="keyword">int</span> *sptr;</span><br><span class="line">    sptr = &amp;Foo::cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向静态成员函数的指针</span></span><br><span class="line">    <span class="keyword">void</span> (*sfptr)(<span class="keyword">void</span>);</span><br><span class="line">    sfptr = Foo::count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针</span></span><br><span class="line">    Foo foo;</span><br><span class="line">    foo.*ptr = <span class="number">65535</span>;</span><br><span class="line">    (foo.*fptr)(<span class="number">65535</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*sptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    (*sfptr)();</span><br><span class="line">    sfptr();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="结构、联合与位段"><a href="#结构、联合与位段" class="headerlink" title="结构、联合与位段"></a>结构、联合与位段</h3><ul>
<li><p>在C++语言中，<code>struct</code>用法同<code>class</code>完全一样，也是用于定义类的关键字。<code>struct</code>定义的类与<code>class</code>定义的类的唯一差别在于默认的访问控制权限不同，<code>class</code>定义的类的默认访问控制权限是<code>private</code>，而利用<code>struct</code>定义的类的默认访问控制权限是<code>public</code>。</p>
</li>
<li><p><code>union</code>也可以定义自己的数据结构和函数（包括构造函数和析构函数），也支持类的三种访问控制权限，<code>union</code>和<code>class</code>的区别如下：</p>
<ul>
<li><p><code>union</code>不支持继承、不能定义虚函数。</p>
</li>
<li><p><code>union</code>的默认访问控制权限是<code>public</code>。</p>
</li>
<li><code>union</code>的成员变量共享内存，这使得静态变量、引用变量、含有自定义的构造函数、析构函数、拷贝赋值运算符、虚函数的类对象不能成为联合中的数据成员。</li>
</ul>
</li>
<li><p>由于系统对内存的最小操作单元是字节而一个字节由8个二进制位组成，所以无论多小的数都要至少由8个二进制位表示。为了使只需要几个二进制位的数据能够使用更少的二进制为表示，C++提供了位段数据类型，位段可以通过<code>struct</code>或<code>class</code>关键字来定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uint2:<span class="number">2</span> <span class="comment">// uint2占两个比特</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uint4:<span class="number">4</span> <span class="comment">// uint4占四个比特</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="运算符的重载（《C-Primer》）"><a href="#运算符的重载（《C-Primer》）" class="headerlink" title="运算符的重载（《C++ Primer》）"></a>运算符的重载（《C++ Primer》）</h2><hr>
<ul>
<li>重载的运算符是一种特殊类型的函数，它们的名字由关键字<code>operator</code>和其后面要定义的运算符号共同完成，和其他函数一样包含返回类型、参数列表以及函数体。重载运算符的参数数量应与运算对象的数量一样多，且不能含有默认参数，一元运算符有一个参数，二元运算符有两个参数，其左侧运算对象作为其第一个参数，右侧运算对象作为其第二个参数。位于类中的重载运算符，由于其第一个运算对象绑定到隐式的<code>this</code>指针上，故，成员运算符函数的显式参数应该比运算符的运算对象少一个。几乎所有的运算符均可被重载，作为特例的只有域限定运算符<code>::</code>、成员访问运算符<code>.</code>和条件运算符<code>? :</code>。另外地，由于逻辑与运算符<code>&amp;&amp;</code>、逻辑或运算符<code>||</code>和逗号运算符<code>,</code>在重载后不能保持原有的求值顺序，且破坏掉了<code>&amp;&amp;</code>和<code>||</code>原有的短路属性，不建议对这三个运算符进行重载。</li>
</ul>
<h3 id="输入输出运算符的重载"><a href="#输入输出运算符的重载" class="headerlink" title="输入输出运算符的重载"></a>输入输出运算符的重载</h3><ul>
<li>输出运算符的第一个形参一般是一个非常量的<code>ostream</code>对象的引用，第二个形参一般是一个常量的引用，该常量是我们要打印的类型。为了与其他输出运算符保持一致，<code>operator &lt;&lt;</code>一般要返回其<code>ostream</code>形参。下面是一个输入运算符重载的例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Complex &amp;foo) &#123;</span><br><span class="line">    os&lt;&lt;foo.real&lt;&lt;<span class="string">&quot; + &quot;</span>&lt;&lt;foo.imag&lt;&lt;<span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>输入运算符的第一个形参通常是要读取的流的引用，第二个形参通常是要读取到的非常量对象的引用，该运算符通常会返回某个给定流的引用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt;(istream &amp;is, Complex &amp;foo) &#123;</span><br><span class="line">    is&gt;&gt;foo.real&gt;&gt;foo.imag;</span><br><span class="line">    <span class="keyword">if</span>(!is) &#123;</span><br><span class="line">        foo = Complex();</span><br><span class="line">    &#125; <span class="comment">// 检查输入状态，若输入失败，将对象赋予默认状态。</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算术运算符的重载"><a href="#算术运算符的重载" class="headerlink" title="算术运算符的重载"></a>算术运算符的重载</h3></li>
<li>算术运算符由于不需要对运算对象进行改变，所以其形参都是常量的引用，算术运算符通常会计算两个运算对象并得到一个新值，这个值有别于任何一个运算对象，常常位于一个局部变量内，操作完成后返回该局部变量的副本作为其结果。下面将分别给出算数运算符重载的几种情况的示例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> real;</span><br><span class="line">    <span class="keyword">int</span> imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">int</span> r, <span class="keyword">int</span> i);</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;second);</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">int</span> second);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> Complex &amp;second);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex::Complex(<span class="keyword">int</span> r, <span class="keyword">int</span> i): real(r), imag(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符函数用于处理两个运算对象都是自定义类的情况</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;second) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(real+second.real, imag+second.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符函数用于处理第二个运算对象不是自定义类的情况</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">int</span> second) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(real+secoond, imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为由于函数的重载运算符函数用于处理第一个运算对象不是自定义类的情况</span></span><br><span class="line">Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> Complex &amp;second) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(first+second.real, second.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>算术复合赋值运算符的重载和算术运算符的重载唯一的区别是需要将运算的结果保存在当前的运算对象中而不是另一个运算对象中，下面是一个复合赋值运算符重载的例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex &amp;<span class="keyword">operator</span> +=(<span class="keyword">const</span> Complex &amp;second) &#123;</span><br><span class="line">    real += second.real;</span><br><span class="line">    imag += second.imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="递增和递减运算符的重载"><a href="#递增和递减运算符的重载" class="headerlink" title="递增和递减运算符的重载"></a>递增和递减运算符的重载</h3><ul>
<li>递增运算符和递减运算符有前置版本和后置版本，为了与内置版本保持一致，前置运算符通常应该返回递增或递减后对象的一个引用，而后置运算符应返回递增或递减前的一个值。由于前置版本和后置版本运算对象的类型和数目是相同的，为了能够区分二者的重载，后置版本接受一个额外的（不被使用）<code>int</code>类型形参，编译时，编译器为这个形参赋一个值为$0$的实参。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;Foo::<span class="keyword">operator</span> ++ &#123;</span><br><span class="line">    ++(<span class="keyword">this</span>-&gt;foo);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo Foo::<span class="keyword">operator</span> --(<span class="keyword">int</span>) &#123;</span><br><span class="line">    Foo bar = *<span class="keyword">this</span></span><br><span class="line">    --(<span class="keyword">this</span>-&gt;foo);</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><ul>
<li>C++语言中，通过使用已有的类并在此基础上追加新的功能就可以派生出新的类，这一处理关系被称为继承。被继承的类称为基类，通过继承而产生的新类被称为派生类或导出类。通常基类和派生类又被称为父类和子类。派生类继承了基类的功能，在派生类的构造函数和其他成员函数中可以访问基类的非<code>private</code>成员函数。</li>
<li>派生类的定义形式如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式 基类名 &#123;</span><br><span class="line">    追加的数据成员</span><br><span class="line">    追加的成员函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>派生类的继承方式有三种：公有继承<code>public</code>、私有继承<code>private</code>、保护继承<code>protected</code>，默认继承方式是<code>private</code>。在这三种继承方式下，访问控制权限的处理关系如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基类</th>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">派生类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code>成员</td>
<td style="text-align:center">公有继承</td>
<td style="text-align:center"><code>public</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code>成员</td>
<td style="text-align:center">公有继承</td>
<td style="text-align:center"><code>protected</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code>成员</td>
<td style="text-align:center">公有继承</td>
<td style="text-align:center">不可访问</td>
</tr>
<tr>
<td style="text-align:center"><code>public</code>成员</td>
<td style="text-align:center">保护继承</td>
<td style="text-align:center"><code>protected</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code>成员</td>
<td style="text-align:center">保护继承</td>
<td style="text-align:center"><code>protected</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code>成员</td>
<td style="text-align:center">保护继承</td>
<td style="text-align:center">不可访问</td>
</tr>
<tr>
<td style="text-align:center"><code>public</code>成员</td>
<td style="text-align:center">私有继承</td>
<td style="text-align:center"><code>private</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code>成员</td>
<td style="text-align:center">私有继承</td>
<td style="text-align:center"><code>private</code>处理</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code>成员</td>
<td style="text-align:center">私有继承</td>
<td style="text-align:center">不可访问</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>若在基类和派生类中有同名函数，则在派生类中使用基类的同名函数时，需要使用域作用限定符来加以区分。</li>
</ul>
<h3 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h3><ul>
<li><p>虚函数的定义实在基类的函数前面加上<code>virtual</code>关键字，用来描述基类和派生类之间逻辑上的抽象关系。虚函数在派生类中的函数原型与在基类中的函数原型须完全相同方可被认定为虚函数。当一个函数被定义成虚函数以后，就可以通过一个指向基类的指针来实现程序的多态性，当把这个指针指向一个派生类的对象之后，有如下的调用规则：</p>
<ul>
<li><p>若指针所调用的函数只在基类中存在，则直接调用基类中的函数。</p>
</li>
<li><p>若指针所调用的函数只在派生类中存在，将发生编译错误。</p>
</li>
<li><p>若指针所调用的函数在基类和派生类中均存在，但不是虚函数，则将调用基类中的函数。</p>
</li>
<li><p>若指针所调用的函数在基类和派生类中均存在，且是虚函数，则将调用派生类中的函数。</p>
</li>
</ul>
</li>
<li>虚函数的多态只能通过指针或者引用访问来实现，使用变量名访问不能实现多态。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* PASS */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span> <span class="keyword">public</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* Another Function */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Foo *ptr;</span><br><span class="line">    Bar bar;</span><br><span class="line">    ptr = &amp;bar;</span><br><span class="line">    ptr-&gt;foo_bar(); <span class="comment">// 指针可以实现多态</span></span><br><span class="line"></span><br><span class="line">    Foo &amp;ref = bar;</span><br><span class="line">    ref.foo_bar(); <span class="comment">// 引用可以实现多态</span></span><br><span class="line"></span><br><span class="line">    Foo obj = bar;</span><br><span class="line">    obj.foo_bar(); <span class="comment">// 不能实现多态，将调用基类中的foo_bar()函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>派生类对象的地址可以赋值给一个基类对象的指针，但是基类对象的地址不可以赋值给派生类对象的指针。同一个基类的不同派生类对象的指针不能够自动地相互转换，要通过显式地强制类型转换完成。</li>
<li>没有在基类中定义函数体的虚函数被称为纯虚函数。纯虚函数在基类中只有函数声明，且在函数声明后面加上了<code>=0</code>说明；在派生类中必须要给出纯虚函数的定义。需要注意的是，不能创建包含纯虚函数的类的对象。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数的定义形式</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> bar)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>包含纯虚函数的类被称为抽象类，以抽象类为基类来生成派生类时，必须要在派生类中给出纯虚函数地定义，否则，该派生类也将自动成为一个抽象类。抽象类不能定义其对象。</li>
</ul>
<h3 id="多重继承与虚拟基类"><a href="#多重继承与虚拟基类" class="headerlink" title="多重继承与虚拟基类"></a>多重继承与虚拟基类</h3><ul>
<li>在C++语言中，只继承一个基类而生成的派生类被称为单一继承或单继承；通过继承多个基类而生成的派生类叫多重继承或多继承。多重继承也可以称作多重基类，它的定义形式为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="keyword">public</span> Bar, <span class="keyword">public</span> Baz &#123;</span><br><span class="line">    <span class="comment">// Some Function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在应用多重继承时，存在一种情况是几个基类都是同一个父类的不同子类，这时，多重继承产生的派生类将间接继承了多次基类的父类中的函数，这时若对这个派生类的对象调用基类的父类中的成员函数，系统将无法判断调用哪个基类中所继承的这个函数引起错误，必须通过作用域限定符显式地指定调用哪一个基类中的该函数。为解决这一问题，C++语言中提出了虚拟基类的概念。在定义派生类时，在基类前面加上<code>virtual</code>关键字可以将这个基类说明为虚拟基类。虚拟基类可以保证只有一个基类对象被继承。在使用虚拟基类时，只要有一个基类的成员被修改了，其他基类中的成员也将同时被修改。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="comment">// Base Function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// Derived Class 1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// Derived Class 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span>:</span> <span class="keyword">public</span> Foo, <span class="keyword">public</span> Bar &#123;</span><br><span class="line">    <span class="comment">// 使用了虚拟基类的多重继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="继承方式下的构造和析构"><a href="#继承方式下的构造和析构" class="headerlink" title="继承方式下的构造和析构"></a>继承方式下的构造和析构</h3><ul>
<li><p>当某个类中既有基类，又有对象数据成员时，再调用该类的构造函数时，包括基类的构造函数和对象成员的构造函数在内的构造函数的调用符合以下流程：</p>
<ul>
<li><p>调用基类的构造函数：其调用顺序按照继承操作时冒号后面给出的基类的排列顺序，弱国基类中还包括对象数据成员，则先调用该数据成员的构造函数再执行相应基类的构造函数体。</p>
</li>
<li><p>调用类中对象数据成员的构造函数：其调用顺序按照它们在类中的定义顺序。</p>
</li>
<li>执行本派生类的构造函数体。</li>
</ul>
</li>
<li><p>析构函数的调用顺序是构造函数调用顺序的严格逆序。</p>
</li>
</ul>
<h3 id="explicit关键字和typeid运算符"><a href="#explicit关键字和typeid运算符" class="headerlink" title="explicit关键字和typeid运算符"></a><code>explicit</code>关键字和<code>typeid</code>运算符</h3><ul>
<li><p><code>explicit</code>关键字用来禁用变换构造函数，被<code>explicit</code>关键字修饰的单变量构造函数只能显示地调用，而不能像变换构造函数一样利用类似赋值语句的形式调用。修饰在其他类型的构造函数前面的<code>explicit</code>关键字无实际意义。</p>
</li>
<li><p><code>typeid</code>运算符用于在程序运行的过程中确定一个对象的类型。其返回值是<code>const type_info &amp;</code>类型的，在程序中将头文件<code>typeinfo</code>包含进来可以方便地对<code>type_info</code>类进行解析。下面的一段示例程序给出了<code>typeid</code>运算符的使用方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Base;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(ptr).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// Output: class Base</span></span><br><span class="line">    p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(*ptr).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// Output: class Derived *</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板和异常处理"><a href="#模板和异常处理" class="headerlink" title="模板和异常处理"></a>模板和异常处理</h2></li>
</ul>
<hr>
<h3 id="函数模板和类模板"><a href="#函数模板和类模板" class="headerlink" title="函数模板和类模板"></a>函数模板和类模板</h3><ul>
<li>在程序设计的过程中存在这样的现象：程序中定义的多个函数有着完全一样的函数体，只是他们的参数类型不一样。在C++语言中，对这样的几个函数可以先给出其通用的定义框架再将具体的参数及其类型传递给它，这就是模板的概念。C++提供函数模板和类模板。</li>
<li>函数模板的定义形式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;模板参数表&gt; 返回值类型 函数名(参数表) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>同一般函数一样，模板函数也支持重载。只要模板函数的参数类型或参数个数不同，就可以重载函数模板。当一般函数与模板函数重名时，系统会先匹配类型完全相同的一般重载函数（非模板函数），如果没有满足的非模板函数，再匹配模板函数。</li>
<li>类模板的一般定义形式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;模板参数表&gt;</span><br><span class="line">class 类名 &#123;</span><br><span class="line">    数据成员</span><br><span class="line">    成员函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3></li>
<li><p>C++中与异常处理有关的关键字主要有三个：<code>try</code>、<code>throw</code>和<code>catch</code>。</p>
<ul>
<li><p><code>try</code>关键字用于限定进行错误检查的程序部分，没有使用<code>try</code>关键字括起来的部分不作为语法检查的部分。当这部分程序段中检测出错误时，程序不会立即处理，而是产生一个用来表示某种错误的字符串或数值。</p>
</li>
<li><p><code>throw</code>关键字在<code>try</code>关键字所括起来的程序段中使用，将产生的错误信息传递出去，以便在<code>catch</code>程序段中进行处理。</p>
</li>
<li><code>catch</code>关键字捕获<code>throw</code>抛出的错误信息，并根据信息的类型做出相应的处理。<code>catch</code>语句在<code>try</code>语句的后面使用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Error <span class="number">1</span>) <span class="keyword">throw</span> <span class="string">&quot;Error!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(Error <span class="number">2</span>) <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(Error <span class="number">3</span>) <span class="keyword">throw</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">char</span> *errstr) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;errstr&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 具体的处理方式</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">int</span> errno) &#123;</span><br><span class="line">    <span class="comment">// 具体的处理方式</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(···) &#123;</span><br><span class="line">    <span class="comment">// 其余类型的异常处理</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>作为面向对象的程序设计语言，C++语言的异常处理可以抛出对象，而且可以在抛出异常之前进行一定的后处理，系统将自动地调用发生异常的函数所定义的所有局部对象的析构函数。异常处理对象的定义和使用如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义异常处理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *errmsg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Exception(<span class="keyword">char</span> *errstr = <span class="string">&quot;Error Occurred!&quot;</span>) &#123;</span><br><span class="line">        errmsg = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(errstr)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(errmsg, errstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">msgGet</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errmsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用异常处理对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Error) <span class="keyword">throw</span> Exception(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception err) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;err.msgGet()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://Bye-lemon.github.io">李英平</a>
            <p>原文链接：<a href="http://bye-lemon.github.io/post/ab83/">http://bye-lemon.github.io/post/ab83/</a>
            <p>发表日期：<a href="http://bye-lemon.github.io/post/ab83/">October 29th 2018, 12:43:55 pm</a>
            <p>更新日期：<a href="http://bye-lemon.github.io/post/ab83/">January 17th 2021, 1:45:09 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/post/a140/" title="IPv6环境下的一次Docker部署实践">
                    <div class="nextTitle">IPv6环境下的一次Docker部署实践</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/post/bdef/" title="一个菜鸟程序员打磨工具的日常">
                    <div class="prevTitle">一个菜鸟程序员打磨工具的日常</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
        

    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:2576413114@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Bye-lemon" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
            
                <a href="//weibo.com/u/5679329267" class="iconfont-archer weibo" target="_blank" title=weibo></a>
            
        
    
        
            
                <a href="//zhihu.com/people/li-ying-ping-89-54" class="iconfont-archer zhihu" target="_blank" title=zhihu></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">绪言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">数据类型、运算符与基本语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">C++的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.</span> <span class="toc-text">C++的运算符与基本语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">数据的输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.</span> <span class="toc-text">标准输入和输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">C++的文件处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">数组、指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">数组和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">4.3.</span> <span class="toc-text">内存的申请与释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">返回指针和引用的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%82%A8%E5%AD%98%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">变量的作用域和储存类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.4.</span> <span class="toc-text">C++中函数的新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">类的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-amp-%E5%8F%98%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">复制构造函数 &amp; 变换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">6.4.</span> <span class="toc-text">类的静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.5.</span> <span class="toc-text">常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">6.6.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">6.7.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89"><span class="toc-number">6.8.</span> <span class="toc-text">类的嵌套定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">6.9.</span> <span class="toc-text">对象数组与指向类的成员的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E3%80%81%E8%81%94%E5%90%88%E4%B8%8E%E4%BD%8D%E6%AE%B5"><span class="toc-number">6.10.</span> <span class="toc-text">结构、联合与位段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%88%E3%80%8AC-Primer%E3%80%8B%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">运算符的重载（《C++ Primer》）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">7.1.</span> <span class="toc-text">输入输出运算符的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">7.2.</span> <span class="toc-text">算术运算符的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">7.3.</span> <span class="toc-text">递增和递减运算符的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">8.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">8.2.</span> <span class="toc-text">虚函数和多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">多重继承与虚拟基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">8.4.</span> <span class="toc-text">继承方式下的构造和析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Ctypeid%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.5.</span> <span class="toc-text">explicit关键字和typeid运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">模板和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.1.</span> <span class="toc-text">函数模板和类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 42
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/16</span>
            <a class="archive-post-title" href="/post/be6/">当我们落魄到需要去借别人的算力跑实验的时候</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span>
            <a class="archive-post-title" href="/post/6c49/">借助SSH反向代理隧道实现内网服务器的校外访问</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span>
            <a class="archive-post-title" href="/post/f81/">Windows 10系统下使用SMB实现媒体文件共享</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/29</span>
            <a class="archive-post-title" href="/post/fab7/">避重就轻的论文阅读笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/17</span>
            <a class="archive-post-title" href="/post/258b/">DLUT校园网自动认证的解决方案</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/post/b346/">《高级操作系统》复习纲要</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/30</span>
            <a class="archive-post-title" href="/post/89b2/">自动驾驶中间件Cyber RT中的实时通信机制简述</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/post/45b8/">2020年电赛G题不完全实现方案</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/post/9dd7/">如何为Hexo博客构建一个简单的全文搜索引擎</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/post/3eb8/">Apollo D-Kit 调试笔记（四）：基于Camera的自动驾驶</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/post/d69d/">Apollo D-Kit 调试笔记（三）：基于Lidar的自动驾驶</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span>
            <a class="archive-post-title" href="/post/d2b3/">Apollo D-Kit 调试笔记（二）：动力学标定与循迹验证</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/15</span>
            <a class="archive-post-title" href="/post/11e/">Apollo D-Kit 调试笔记（一）：系统安装与传感器集成</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span>
            <a class="archive-post-title" href="/post/d923/">Apollo D-Kit 调试笔记（零）：修车备忘录</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span>
            <a class="archive-post-title" href="/post/ffa2/">《Query-guided End-to-End Person Search》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span>
            <a class="archive-post-title" href="/post/c6f5/">《Joint Detection and Identification Feature Learning for Person Search》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/11</span>
            <a class="archive-post-title" href="/post/cde6/">行人重识别（Person Re-identification）研究概述</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span>
            <a class="archive-post-title" href="/post/7f95/">《Transferable, Controllable, and Inconspicuous Adversarial Attacks on Person Re-identification With Deep Mis-Ranking》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span>
            <a class="archive-post-title" href="/post/4d08/">《Weakly supervised discriminative feature learning with state information for person identification》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span>
            <a class="archive-post-title" href="/post/8337/">《Pose-guided Visible Part Matching for Occluded Person ReID》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span>
            <a class="archive-post-title" href="/post/aa5f/">《COCAS: A Large-Scale Clothes Changing Person Dataset for Re-identification》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/post/dbc2/">《YOLO v4: Optimal Speed and Accuracy of Object Detection》论文笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span>
            <a class="archive-post-title" href="/post/1271/">Aurora在Refresh时报错Running Problem Latex的若干玄学解决方案</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span>
            <a class="archive-post-title" href="/post/3acc/">Windows系统下带有NonFree功能的OpenCV编译笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/03</span>
            <a class="archive-post-title" href="/post/f2f7/">《计算机网络安全教程》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span>
            <a class="archive-post-title" href="/post/4129/">面向ARM架构的嵌入式系统设计学习笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/30</span>
            <a class="archive-post-title" href="/post/b76d/">MI MIX2S(Polaris)全程负优化记录</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/02</span>
            <a class="archive-post-title" href="/post/e9de/">《并行程序设计导论》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span>
            <a class="archive-post-title" href="/post/4849/">《软件综合训练》实训笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span>
            <a class="archive-post-title" href="/post/363b/">那些年，我们调过的嵌入式开发平台</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span>
            <a class="archive-post-title" href="/post/e971/">使用Altium Designer 19绘制劣质PCB的流程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span>
            <a class="archive-post-title" href="/post/9cb2/">《数据库系统概论（第四版）》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span>
            <a class="archive-post-title" href="/post/30ad/">《代码大全》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span>
            <a class="archive-post-title" href="/post/6003/">tmux Cheatsheet</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/15</span>
            <a class="archive-post-title" href="/post/9087/">《黑客与画家》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/post/f0bc/">Standford University CS183B（如何创业）学习笔记</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/31</span>
            <a class="archive-post-title" href="/post/e061/">Brainfuck与2019的新年仪式感</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/25</span>
            <a class="archive-post-title" href="/post/10d1/">《计算机网络（第7版）》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span>
            <a class="archive-post-title" href="/post/a140/">IPv6环境下的一次Docker部署实践</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/29</span>
            <a class="archive-post-title" href="/post/ab83/">《C++语言程序设计教程》读书笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span>
            <a class="archive-post-title" href="/post/bdef/">一个菜鸟程序员打磨工具的日常</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/23</span>
            <a class="archive-post-title" href="/post/a87/">《图解TCP/IP》读书笔记</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="Apollo">
                <span class="iconfont-archer">&#xe606;</span>
                Apollo
            </span>
        
            <span class="sidebar-tag-name" data-tags="Re-ID">
                <span class="iconfont-archer">&#xe606;</span>
                Re-ID
            </span>
        
            <span class="sidebar-tag-name" data-tags="CVPR">
                <span class="iconfont-archer">&#xe606;</span>
                CVPR
            </span>
        
            <span class="sidebar-tag-name" data-tags="DLUT">
                <span class="iconfont-archer">&#xe606;</span>
                DLUT
            </span>
        
            <span class="sidebar-tag-name" data-tags="Aurora2">
                <span class="iconfont-archer">&#xe606;</span>
                Aurora2
            </span>
        
            <span class="sidebar-tag-name" data-tags="MS Office">
                <span class="iconfont-archer">&#xe606;</span>
                MS Office
            </span>
        
            <span class="sidebar-tag-name" data-tags="IPv6">
                <span class="iconfont-archer">&#xe606;</span>
                IPv6
            </span>
        
            <span class="sidebar-tag-name" data-tags="Docker">
                <span class="iconfont-archer">&#xe606;</span>
                Docker
            </span>
        
            <span class="sidebar-tag-name" data-tags="Cernet">
                <span class="iconfont-archer">&#xe606;</span>
                Cernet
            </span>
        
            <span class="sidebar-tag-name" data-tags="Person Search">
                <span class="iconfont-archer">&#xe606;</span>
                Person Search
            </span>
        
            <span class="sidebar-tag-name" data-tags="刷机">
                <span class="iconfont-archer">&#xe606;</span>
                刷机
            </span>
        
            <span class="sidebar-tag-name" data-tags="小米">
                <span class="iconfont-archer">&#xe606;</span>
                小米
            </span>
        
            <span class="sidebar-tag-name" data-tags="Android">
                <span class="iconfont-archer">&#xe606;</span>
                Android
            </span>
        
            <span class="sidebar-tag-name" data-tags="OpenCV">
                <span class="iconfont-archer">&#xe606;</span>
                OpenCV
            </span>
        
            <span class="sidebar-tag-name" data-tags="tmux">
                <span class="iconfont-archer">&#xe606;</span>
                tmux
            </span>
        
            <span class="sidebar-tag-name" data-tags="Linux">
                <span class="iconfont-archer">&#xe606;</span>
                Linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="Object Detection">
                <span class="iconfont-archer">&#xe606;</span>
                Object Detection
            </span>
        
            <span class="sidebar-tag-name" data-tags="计算机网络">
                <span class="iconfont-archer">&#xe606;</span>
                计算机网络
            </span>
        
            <span class="sidebar-tag-name" data-tags="TCP/IP">
                <span class="iconfont-archer">&#xe606;</span>
                TCP/IP
            </span>
        
            <span class="sidebar-tag-name" data-tags="程序员">
                <span class="iconfont-archer">&#xe606;</span>
                程序员
            </span>
        
            <span class="sidebar-tag-name" data-tags="并行程序设计">
                <span class="iconfont-archer">&#xe606;</span>
                并行程序设计
            </span>
        
            <span class="sidebar-tag-name" data-tags="数据库">
                <span class="iconfont-archer">&#xe606;</span>
                数据库
            </span>
        
            <span class="sidebar-tag-name" data-tags="DUT">
                <span class="iconfont-archer">&#xe606;</span>
                DUT
            </span>
        
            <span class="sidebar-tag-name" data-tags="备考">
                <span class="iconfont-archer">&#xe606;</span>
                备考
            </span>
        
            <span class="sidebar-tag-name" data-tags="信息安全">
                <span class="iconfont-archer">&#xe606;</span>
                信息安全
            </span>
        
            <span class="sidebar-tag-name" data-tags="Kali Linux">
                <span class="iconfont-archer">&#xe606;</span>
                Kali Linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="创业">
                <span class="iconfont-archer">&#xe606;</span>
                创业
            </span>
        
            <span class="sidebar-tag-name" data-tags="操作系统">
                <span class="iconfont-archer">&#xe606;</span>
                操作系统
            </span>
        
            <span class="sidebar-tag-name" data-tags="SMB">
                <span class="iconfont-archer">&#xe606;</span>
                SMB
            </span>
        
            <span class="sidebar-tag-name" data-tags="Windows 10">
                <span class="iconfont-archer">&#xe606;</span>
                Windows 10
            </span>
        
            <span class="sidebar-tag-name" data-tags="Altium Designer">
                <span class="iconfont-archer">&#xe606;</span>
                Altium Designer
            </span>
        
            <span class="sidebar-tag-name" data-tags="Brainfuck">
                <span class="iconfont-archer">&#xe606;</span>
                Brainfuck
            </span>
        
            <span class="sidebar-tag-name" data-tags="导航">
                <span class="iconfont-archer">&#xe606;</span>
                导航
            </span>
        
            <span class="sidebar-tag-name" data-tags="docker">
                <span class="iconfont-archer">&#xe606;</span>
                docker
            </span>
        
            <span class="sidebar-tag-name" data-tags="nvidia-docker">
                <span class="iconfont-archer">&#xe606;</span>
                nvidia-docker
            </span>
        
            <span class="sidebar-tag-name" data-tags="docker-compose">
                <span class="iconfont-archer">&#xe606;</span>
                docker-compose
            </span>
        
            <span class="sidebar-tag-name" data-tags="rsync">
                <span class="iconfont-archer">&#xe606;</span>
                rsync
            </span>
        
            <span class="sidebar-tag-name" data-tags="CS183B">
                <span class="iconfont-archer">&#xe606;</span>
                CS183B
            </span>
        
            <span class="sidebar-tag-name" data-tags="卓英训练营">
                <span class="iconfont-archer">&#xe606;</span>
                卓英训练营
            </span>
        
            <span class="sidebar-tag-name" data-tags="ARM">
                <span class="iconfont-archer">&#xe606;</span>
                ARM
            </span>
        
            <span class="sidebar-tag-name" data-tags="工具">
                <span class="iconfont-archer">&#xe606;</span>
                工具
            </span>
        
            <span class="sidebar-tag-name" data-tags="C++">
                <span class="iconfont-archer">&#xe606;</span>
                C++
            </span>
        
            <span class="sidebar-tag-name" data-tags="Nvidia Jetson Xavier">
                <span class="iconfont-archer">&#xe606;</span>
                Nvidia Jetson Xavier
            </span>
        
            <span class="sidebar-tag-name" data-tags="Nvidia Jetson Nano">
                <span class="iconfont-archer">&#xe606;</span>
                Nvidia Jetson Nano
            </span>
        
            <span class="sidebar-tag-name" data-tags="HiKey 970">
                <span class="iconfont-archer">&#xe606;</span>
                HiKey 970
            </span>
        
            <span class="sidebar-tag-name" data-tags="FPGA">
                <span class="iconfont-archer">&#xe606;</span>
                FPGA
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="开发和调试笔记">
            <span class="iconfont-archer">&#xe60a;</span>
            开发和调试笔记
        </span>
    
        <span class="sidebar-category-name" data-categories="论文笔记">
            <span class="iconfont-archer">&#xe60a;</span>
            论文笔记
        </span>
    
        <span class="sidebar-category-name" data-categories="英平的工具箱">
            <span class="iconfont-archer">&#xe60a;</span>
            英平的工具箱
        </span>
    
        <span class="sidebar-category-name" data-categories="Cheatsheet">
            <span class="iconfont-archer">&#xe60a;</span>
            Cheatsheet
        </span>
    
        <span class="sidebar-category-name" data-categories="读书笔记">
            <span class="iconfont-archer">&#xe60a;</span>
            读书笔记
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        root: "/",
        author: "李英平"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
            <script src='https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js'></script>
            <script>
                if (window.mermaid) {
                    mermaid.initialize({theme: 'dark'});
                }
            </script>
        
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false}});</script></body>
</html>
